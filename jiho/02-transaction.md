## 1. 트랜잭션 (Transaction)

### 1.1. 개념

- 하나 이상의 쿼리를 단일 작업으로 묶어 나누어질 수 없도록 만든 것
- **논리적인 작업 셋을 모두 완벽하게 처리(Commit)** 하거나, **처리하지 못하는 경우에는 원상태로 복구(Rollback)** 시켜 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않도록 만들어주는 기능
  - 즉, **데이터 정합성** 을 보장하기 위한 기능
- 트랜잭션이 없다면 부분 업데이트 현상이 발생하는 경우, 실패한 쿼리로 인해남은 레코드를 다시 삭제하는 재처리 작업을 애플리케이션 단에서 추가적으로 수행해줘야 함
- InnoDB는 트랜잭션을 지원하지만, MyISAM이나 MEMORY와 같은 스토리지 엔진은 트랜잭션을 지원하지 않음

<aside>

**참고 - 트랜잭션의 ACID 속성**

- **원자성 (Atomicity) :** 한 트랜잭션의 연산들이 **모두 성공하거나, 모두 실패**해야 함. 하나의 단위로 묶여있는 여러 작업이 부분적으로 실행되어 데이터가 오염되는 것을 방지
- **일관성 (Consistency) :** 데이터베이스의 상태는 트랜잭션 이전과 이후 모두 이전과 같이 유효해야 함
  예) 이름이 공백이어서는 안된다는 제약조건이 있는 경우, 트랜잭션 이후의 데이터는 해당 제약조건을 지켜야 함. 그렇지 않으면 롤백해야 함
- **고립성 (Isolation) :** 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 함. 각 트랜잭션은 다른 트랜잭션에 영향을 주지 않고, 독립적으로 실행되는 것 처럼 보여야 함. 격리 수준으로 설정 가능
- **지속성 (Durability) :** 트랜잭션의 결과는 영구적으로 저장되어야 함. 시스템 오류가 발생하더라도 커밋된 기록은 영구적이어야 함
</aside>

### 1.2. 주의 사항

- 꼭 필요한 최소한의 코드에만 적용하여 **데이터베이스 커넥션을 가지고 있는 범위 및 트랜잭션 범위를 최소화** 해야 함
  - 각 단위 프로그램이 커넥션을 점유하는 시간이 길어질수록 사용 가능한 여유 커넥션 개수가 줄어들고, 어느 순간에는 **커넥션을 가져가기 위해 기다려야 하는 상황**이 발생할 수도 있음
  - 장시간 트랜잭션을 종료하지 않으면, 해당 트랜잭션에게 MVCC를 지원하기 위한 **언두 영역이 백업된 데이터로 무한정 커질 수 있음**
- 메일 전송이나 FTP 파일 전송 등, 네트워크를 통해 원격 서버와 통신하는 작업은 **트랜잭션에서 제거**해야 함
  - 메일 서버(외부 서버)와 통신할 수 없는 상황이 발생했을 때 웹 서버 뿐만 아니라, 데이터베이스까지 장애가 전파될 수 있기 때문

> 추가 문제 뇌피셜 :
>
> - 외부 서버와의 통신 실패로 인해 다른 작업들도 모두 롤백될 수 있는 가능성 존재,
> - 트랜잭션이 오래 유지되면서 더 많은 데이터에 잠금이 발생해 동시성 저하

## 2. MySQL의 트랜잭션 격리 수준

### 2.1. 트랜잭션 격리 수준

- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 것
- 종류
  - `READ UNCOMMITTED` < `READ COMMITTED` < `REPEATABLE READ` < `SERIALIZABLE`
  - 격리 수준이 높아질수록 동시 처리 성능도 떨어지는 것이 일반적이지만, SERIALIZABLE이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음

### 2.2. 트랜잭션의 부정합 문제

- **Dirty Read :** 어떤 트랜잭션에서 처리한 **작업이 완료(커밋 or 롤백)되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상**
- **Non-Repeatable Read :** 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했음에도 같은 결과를 가져오지 못하는 현상
  - ↔ Repeatable Read : 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 하는 정합성
- **Phantom Read :** 검색 시 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상

### 2.2. READ UNCOMMITTED

- 각 트랜잭션의 변경 내용이 **커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 보임**
  - 트랜잭션A 처리 도중 문제가 발생해 INSERT된 내용을 롤백한다고 하더라도, 트랜잭션 B에서는 해당 데이터를 사용해 비즈니스 로직을 수행해버릴 수 있는 문제가 발생함
  - 즉, **더티 리드 발생**

### 2.3. READ COMMITTED

- 어떤 트랜잭션에서 데이터를 변경했을 때, 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
- 언두 로그를 활용한 MVCC를 통해 지원
  - 트랜잭션이 롤백될 가능성에 대비해 **변경되기 전 데이터를 언두 영역에 백업**해두고, **실제 레코드 값을 변경**
    - 트랜잭션A에서 데이터 변경 시 **새로운 값은 테이블에 즉시 기록**하고, **이전 값은 언두 영역에 백업**
    - 이때 **트랜잭션B에서 데이터를 조회 시 언두 로그에 백업된 레코드를 읽음**
    - 최종적으로 트랜잭션A가 커밋되면 그때부터는 다른 트랜잭션에서도 언두로그가 아닌 새롭게 변경된 값을 조회
- 다른 트랜잭션에서 처리가 완료되지 않은 데이터를 볼 수 없기 때문에 **더티 리드는 발생하지 않음**
- 그러나 트랜잭션A에서 데이터 변경 이후 커밋까지 완료된 경우에는 트랜잭션B에서 해당 변경사항을 확인할 수 있음. 즉, **Non-Repeatable Read 발생**
  - 즉, READ COMMITTED 격리 수준에서는 트랜잭션 내에서 실행되는 SELECT 문과 트랜잭션 외부에서 SELECT 문의 차이가 별로 없음
    - 트랜잭션 내에서 실행되는 SELECT 문의 실행 결과가 달라질 수 있기 때문. 트랜잭션의 격리에 대한 이점을 누릴 수 없다고 이해함
  - 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되는 경우 큰 문제가 발생할 수 있음
- 오라클 DBMS의 기본 격리 수준

### 2.4. REPEATABLE READ

- **하나의 트랜잭션** 내에서 **똑같은 SELECT 쿼리**를 실행했을 때 **항상 같은 결과**를 보장함
- READ COMMITTED와 마찬가지로 **MVCC를 사용해 커밋되기 이전의 데이터를 보여줌**
  - REPEATABLE READ와 READ COMMITTED의 차이는 언두 영역에 백업된 레코드의 여러 버전 중, 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있음
    - InnoDB의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 ID를 가지는데, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 **트랜잭션 ID**가 포함되어 있음
    - 언두 영역에 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제함
    - 이때 **REPEATABLE READ 격리 수준**에서는 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 낮은(먼저 실행된) 언두 영역의 데이터는 삭제할 수 없음
      - 즉 MVCC를 지원하기 위해 트랜잭션 시작 시점의 스냅샷을 유지해야 하는데, **트랜잭션 시작 시점보다 이후에 변경된 데이터는 트랜잭션이 종료될 때 까지 언두 영역에 유지되어야 함**
    - 반면 **READ COMMITTED** 격리 수준에서는 **각 쿼리 실행 시점의 최신 커밋된 데이터만 읽으면 되므로, 트랜잭션 전체의 스냅샷을 유지하지 않고 쿼리마다 새로운 스냅샷을 생성**함
      - 언두 영역의 데이터는 해당 쿼리를 실행하는 동안만 필요하고, 쿼리 실행이 끝나면 더이상 필요하지 않음
      - 다른 트랜잭션의 `데이터 변경 ~ 커밋` 사이의 시점에만 언두 로그를 유지하면 됨
  - 위와 같은 특징으로 인해, 한 사용자가 트랜잭션을 시작한 후에 **장시간 트랜잭션을 종료하지 않는 경우 언두 영역이 백업된 데이터로 무한정 커질 수 있음**
- MySQL의 REPEATABLE READ 에서는 일반적으로 팬텀 리드가 발생하지 않지만, `SELECT ... FOR UPDATE` 나 `SELECT ... LOCK IN SHARE MODE` 쿼리로 **조회하려는 레코드에 잠금을 설정하는 경우는 팬텀 리드가 발생**함
  - **언두 레코드에는 잠금을 걸 수 없기 때문**에 언**두 영역의 변경 전 데이터를 가져오는 것이 아닌, 실제 레코드를 읽게 됨**
- 이때 **InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 팬텀 리드가 발생하지 않음**
- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준

### 2.5. SERIALIZABLE

- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 접근할 수 없음. 즉, 트랜잭션을 순차적으로 실행함
- 가장 엄격한 격리 수준으로, 그만큼 동시 처리 성능도 떨어짐
- 이때 SERIALIZABLE은 **순수한 SELECT 작업에서도 공유 락(읽기 잠금)을 획득**해야만 하고, 동시에 **다른 트랜잭션은 해당 레코드를 변경할 수 없게 됨**
  - InnoDB 테이블에서는 순수한 SELECT 작업은 아무런 레코드 작업도 설정하지 않고 실행됨 (Non-locking consistent read)
- 더티 리드, Non-Repeatable Read, 팬텀 리드가 발생하지 않음
